/*DEFINE EL SCHEMA Y REGISTRA EL MODELO DE USUARIO */
// -----------------------------------------------------------------
var mongoose = require('mongoose');
var crypto = require('crypto');
var Schema = mongoose.Schema;

/*MongoDB uses collections to store multiple documents, which aren't required
to have the same structure. However, when dealing with objects, it is sometime
necessary for documents to be similar. Mongoose uses a Schema object to define the
document list of properties, each with its own type and constraints, to enforce the
document structure.*/
var UserSchema = new Schema({
    firstName: String,
    lastName: String,
    email: {
        type: String,
        /*The usage of a match validator here will make sure the email field value matches the given regex expression*/
        match: [/.+\@.+\..+/, "Please fill a valid e-mail address"]
    },
    username: {
        type: String,
        /*the trim property added to the username field. This will make sure your username data will be kept trimmed.*/
        trim: true,
        /*This will tell MongoDB to create a unique index for the username field of the users collections.*/
        unique: true,
        /*To validate field existence in Mongoose, you'll need to use the required property in the field you want to validate*/
        required: 'Username is required',
    },
    password: {
        type: String,
        /*Defining a custom validator is done using the validate property. The validate property value should be an array consisting of 
        a validation function and an error message.*/
        validate: [
            function(password) {
                return password && password.length >= 6;
            },
            'Password should be longer...'
        ]
    },
    /*you'll use to hash your password*/
    salt: {
        type: String
    },
    /*will indicate the strategy used to register the user*/
    provider: {
        type: String,
        required: 'Provider is required'
    },
    /*will indicate the user identifier for the authentication strategy*/
    providerId: String,
    /*use to store the user object retrieved from OAuth providers*/
    providerData: {},
    /*The created date field should be initialized at creation time and save the time the user document
    was initially created*/
    created: {
        type: Date,
        default: Date.now
    },
});

/*fullName sera un virtual field de forma tal que al pedirlo, se calculara a partir de los campos firstName y lastName.*/
/*se agrega tambien un setter para fullName de forma tal de modificar al mismo tiempo first y last.*/
UserSchema.virtual('fullName').get(function() {
    return this.firstName + ' ' + this.lastName;
}).set(function(fullName) {
    var split = fullName.split(' ');
    this.firstName = split[0] || '';
    this.lastName = split[1] || '';
});

/*To add a static method, you will need to declare it as a member of your schema's statics property*/
UserSchema.statics.findOneByUsername = function(username, callback) {
    this.findOne({
        /*'i' is to Perform case-insensitive matching*/
        username: new RegExp(username, 'i')
    }, callback);
};

/*is used to find an available unique username for new users.*/
UserSchema.statics.findUniqueUsername = function(username, suffix, callback) {
    var _this = this;
    var possibleUsername = username + (suffix || '');
    _this.findOne({
        username: possibleUsername
    }, function(err, user) {
        if (!err) {
            if (!user) {
                callback(possibleUsername);
            } else {
                return _this.findUniqueUsername(username, (suffix || 0) +
                    1, callback);
            }
        } else {
            callback(null);
        }
    });
};

/*is used to hash a password string by utilizing Node.js' crypto module*/
UserSchema.methods.hashPassword = function(password) {
    return crypto.pbkdf2Sync(password, this.salt, 10000, 64).toString('base64');
};


/*To add an instance method, you will need to declare it as a member of your schema's methods property*/
/*accepts a string argument, hashes it, and compares it to the current user's hashed password*/
UserSchema.methods.authenticate = function(password) {
    return this.password === this.hashPassword(password);
};

/*pre-save middleware to handle the hashing of your users' passwords.*/
UserSchema.pre('save', function(next) {
    if (this.password) {
        /*first, it creates an autogenerated pseudo-random hashing salt*/
        this.salt = new Buffer(crypto.randomBytes(16).toString('base64'), 'base64');
        /*then it replaces the current user password with a hashed password using the hashPassword() instance method*/
        this.password = this.hashPassword(this.password);
    }
    next();
});


/*A post middleware is defined using the post() method of the schema object*/
/*esta funcion correra despues de ejecutar save() sobre mongo.*/
UserSchema.post('save', function(next) {
    if (this.isNew) {
        console.log('A new user was created!');
    } else {
        console.log('An user was updated!');
    }
});

/*This will force Mongoose to include getters when converting the MongoDB document to a JSON representation and will allow the
output of documents using res.json(). Tambien habilita los campos virtuales como fullName.*/
UserSchema.set('toJSON', {
    getters: true,
    virtuals: true
});

mongoose.model('User', UserSchema);
/*you defined your UserSchema object using the Schema constructor, and then you used the schema
instance to define your User model.*/